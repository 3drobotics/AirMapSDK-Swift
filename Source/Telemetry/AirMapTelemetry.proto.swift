// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "telemetry.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Airmap { public struct Telemetry { }}

public func == (lhs: Airmap.Telemetry.Position, rhs: Airmap.Telemetry.Position) -> Bool {
	if (lhs === rhs) {
		return true
	}
	var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
	fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
	fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
	fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
	fieldCheck = fieldCheck && (lhs.hasAltitudeMMsl == rhs.hasAltitudeMMsl) && (!lhs.hasAltitudeMMsl || lhs.altitudeMMsl == rhs.altitudeMMsl)
	fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
	return fieldCheck
}

public func == (lhs: Airmap.Telemetry.Attitude, rhs: Airmap.Telemetry.Attitude) -> Bool {
	if (lhs === rhs) {
		return true
	}
	var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
	fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
	fieldCheck = fieldCheck && (lhs.hasYaw == rhs.hasYaw) && (!lhs.hasYaw || lhs.yaw == rhs.yaw)
	fieldCheck = fieldCheck && (lhs.hasPitch == rhs.hasPitch) && (!lhs.hasPitch || lhs.pitch == rhs.pitch)
	fieldCheck = fieldCheck && (lhs.hasRoll == rhs.hasRoll) && (!lhs.hasRoll || lhs.roll == rhs.roll)
	fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
	return fieldCheck
}

public func == (lhs: Airmap.Telemetry.Speed, rhs: Airmap.Telemetry.Speed) -> Bool {
	if (lhs === rhs) {
		return true
	}
	var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
	fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
	fieldCheck = fieldCheck && (lhs.hasGroundSpeedMs == rhs.hasGroundSpeedMs) && (!lhs.hasGroundSpeedMs || lhs.groundSpeedMs == rhs.groundSpeedMs)
	fieldCheck = fieldCheck && (lhs.hasTrueHeading == rhs.hasTrueHeading) && (!lhs.hasTrueHeading || lhs.trueHeading == rhs.trueHeading)
	fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
	return fieldCheck
}

public func == (lhs: Airmap.Telemetry.Barometer, rhs: Airmap.Telemetry.Barometer) -> Bool {
	if (lhs === rhs) {
		return true
	}
	var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
	fieldCheck = fieldCheck && (lhs.hasTimestamp == rhs.hasTimestamp) && (!lhs.hasTimestamp || lhs.timestamp == rhs.timestamp)
	fieldCheck = fieldCheck && (lhs.hasBarometerHpa == rhs.hasBarometerHpa) && (!lhs.hasBarometerHpa || lhs.barometerHpa == rhs.barometerHpa)
	fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
	return fieldCheck
}

public extension Airmap.Telemetry {
	public struct TelemetryRoot {
		public static var sharedInstance : TelemetryRoot {
			struct Static {
				static let instance : TelemetryRoot = TelemetryRoot()
			}
			return Static.instance
		}
		public var extensionRegistry:ExtensionRegistry
		
		init() {
			extensionRegistry = ExtensionRegistry()
			registerAllExtensions(extensionRegistry)
		}
		public func registerAllExtensions(registry:ExtensionRegistry) {
		}
	}
	
	final public class Position : GeneratedMessage, GeneratedMessageProtocol {
		// Milliseconds since epoc UTC
		public private(set) var hasTimestamp:Bool = false
		public private(set) var timestamp:UInt64 = UInt64(0)
		
		// Decimal place requirement: 7 decimal places.
		public private(set) var hasLatitude:Bool = false
		public private(set) var latitude:Double = Double(0)
		
		// Decimal place requirement: 7 decimal places.
		public private(set) var hasLongitude:Bool = false
		public private(set) var longitude:Double = Double(0)
		
		// Altitude is always in Meters MSL
		public private(set) var hasAltitudeMMsl:Bool = false
		public private(set) var altitudeMMsl:Float = Float(0)
		
		required public init() {
			super.init()
		}
		override public func isInitialized() -> Bool {
			return true
		}
		override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
			if hasTimestamp {
				try output.writeUInt64(1, value:timestamp)
			}
			if hasLatitude {
				try output.writeDouble(2, value:latitude)
			}
			if hasLongitude {
				try output.writeDouble(3, value:longitude)
			}
			if hasAltitudeMMsl {
				try output.writeFloat(4, value:altitudeMMsl)
			}
			try unknownFields.writeToCodedOutputStream(output)
		}
		override public func serializedSize() -> Int32 {
			var serialize_size:Int32 = memoizedSerializedSize
			if serialize_size != -1 {
				return serialize_size
			}
			
			serialize_size = 0
			if hasTimestamp {
				serialize_size += timestamp.computeUInt64Size(1)
			}
			if hasLatitude {
				serialize_size += latitude.computeDoubleSize(2)
			}
			if hasLongitude {
				serialize_size += longitude.computeDoubleSize(3)
			}
			if hasAltitudeMMsl {
				serialize_size += altitudeMMsl.computeFloatSize(4)
			}
			serialize_size += unknownFields.serializedSize()
			memoizedSerializedSize = serialize_size
			return serialize_size
		}
		public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Airmap.Telemetry.Position> {
			var mergedArray = Array<Airmap.Telemetry.Position>()
			while let value = try parseFromDelimitedFromInputStream(input) {
				mergedArray += [value]
			}
			return mergedArray
		}
		public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Airmap.Telemetry.Position? {
			return try Airmap.Telemetry.Position.Builder().mergeDelimitedFromInputStream(input)?.build()
		}
		public class func parseFromData(data:NSData) throws -> Airmap.Telemetry.Position {
			return try Airmap.Telemetry.Position.Builder().mergeFromData(data, extensionRegistry:Airmap.Telemetry.TelemetryRoot.sharedInstance.extensionRegistry).build()
		}
		public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Position {
			return try Airmap.Telemetry.Position.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
		}
		public class func parseFromInputStream(input:NSInputStream) throws -> Airmap.Telemetry.Position {
			return try Airmap.Telemetry.Position.Builder().mergeFromInputStream(input).build()
		}
		public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Position {
			return try Airmap.Telemetry.Position.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
		}
		public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Airmap.Telemetry.Position {
			return try Airmap.Telemetry.Position.Builder().mergeFromCodedInputStream(input).build()
		}
		public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Position {
			return try Airmap.Telemetry.Position.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
		}
		public class func getBuilder() -> Airmap.Telemetry.Position.Builder {
			return Airmap.Telemetry.Position.classBuilder() as! Airmap.Telemetry.Position.Builder
		}
		public func getBuilder() -> Airmap.Telemetry.Position.Builder {
			return classBuilder() as! Airmap.Telemetry.Position.Builder
		}
		override public class func classBuilder() -> MessageBuilder {
			return Airmap.Telemetry.Position.Builder()
		}
		override public func classBuilder() -> MessageBuilder {
			return Airmap.Telemetry.Position.Builder()
		}
		public func toBuilder() throws -> Airmap.Telemetry.Position.Builder {
			return try Airmap.Telemetry.Position.builderWithPrototype(self)
		}
		public class func builderWithPrototype(prototype:Airmap.Telemetry.Position) throws -> Airmap.Telemetry.Position.Builder {
			return try Airmap.Telemetry.Position.Builder().mergeFrom(prototype)
		}
		public func encode() throws -> Dictionary<String,AnyObject> {
			guard isInitialized() else {
				throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
			}
			
			var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
			if hasTimestamp {
				jsonMap["timestamp"] = "\(timestamp)"
			}
			if hasLatitude {
				jsonMap["latitude"] = NSNumber(double:latitude)
			}
			if hasLongitude {
				jsonMap["longitude"] = NSNumber(double:longitude)
			}
			if hasAltitudeMMsl {
				jsonMap["altitudeMMsl"] = NSNumber(float:altitudeMMsl)
			}
			return jsonMap
		}
		class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Airmap.Telemetry.Position {
			return try Airmap.Telemetry.Position.Builder.decodeToBuilder(jsonMap).build()
		}
		class public func fromJSON(data:NSData) throws -> Airmap.Telemetry.Position {
			return try Airmap.Telemetry.Position.Builder.fromJSONToBuilder(data).build()
		}
		override public func getDescription(indent:String) throws -> String {
			var output = ""
			if hasTimestamp {
				output += "\(indent) timestamp: \(timestamp) \n"
			}
			if hasLatitude {
				output += "\(indent) latitude: \(latitude) \n"
			}
			if hasLongitude {
				output += "\(indent) longitude: \(longitude) \n"
			}
			if hasAltitudeMMsl {
				output += "\(indent) altitudeMMsl: \(altitudeMMsl) \n"
			}
			output += unknownFields.getDescription(indent)
			return output
		}
		override public var hashValue:Int {
			get {
				var hashCode:Int = 7
				if hasTimestamp {
					hashCode = (hashCode &* 31) &+ timestamp.hashValue
				}
				if hasLatitude {
					hashCode = (hashCode &* 31) &+ latitude.hashValue
				}
				if hasLongitude {
					hashCode = (hashCode &* 31) &+ longitude.hashValue
				}
				if hasAltitudeMMsl {
					hashCode = (hashCode &* 31) &+ altitudeMMsl.hashValue
				}
				hashCode = (hashCode &* 31) &+  unknownFields.hashValue
				return hashCode
			}
		}
		
		
		//Meta information declaration start
		
		override public class func className() -> String {
			return "Airmap.Telemetry.Position"
		}
		override public func className() -> String {
			return "Airmap.Telemetry.Position"
		}
		override public func classMetaType() -> GeneratedMessage.Type {
			return Airmap.Telemetry.Position.self
		}
		//Meta information declaration end
		
		final public class Builder : GeneratedMessageBuilder {
			private var builderResult:Airmap.Telemetry.Position = Airmap.Telemetry.Position()
			public func getMessage() -> Airmap.Telemetry.Position {
				return builderResult
			}
			
			required override public init () {
				super.init()
			}
			public var hasTimestamp:Bool {
				get {
					return builderResult.hasTimestamp
				}
			}
			public var timestamp:UInt64 {
				get {
					return builderResult.timestamp
				}
				set (value) {
					builderResult.hasTimestamp = true
					builderResult.timestamp = value
				}
			}
			public func setTimestamp(value:UInt64) -> Airmap.Telemetry.Position.Builder {
				self.timestamp = value
				return self
			}
			public func clearTimestamp() -> Airmap.Telemetry.Position.Builder{
				builderResult.hasTimestamp = false
				builderResult.timestamp = UInt64(0)
				return self
			}
			public var hasLatitude:Bool {
				get {
					return builderResult.hasLatitude
				}
			}
			public var latitude:Double {
				get {
					return builderResult.latitude
				}
				set (value) {
					builderResult.hasLatitude = true
					builderResult.latitude = value
				}
			}
			public func setLatitude(value:Double) -> Airmap.Telemetry.Position.Builder {
				self.latitude = value
				return self
			}
			public func clearLatitude() -> Airmap.Telemetry.Position.Builder{
				builderResult.hasLatitude = false
				builderResult.latitude = Double(0)
				return self
			}
			public var hasLongitude:Bool {
				get {
					return builderResult.hasLongitude
				}
			}
			public var longitude:Double {
				get {
					return builderResult.longitude
				}
				set (value) {
					builderResult.hasLongitude = true
					builderResult.longitude = value
				}
			}
			public func setLongitude(value:Double) -> Airmap.Telemetry.Position.Builder {
				self.longitude = value
				return self
			}
			public func clearLongitude() -> Airmap.Telemetry.Position.Builder{
				builderResult.hasLongitude = false
				builderResult.longitude = Double(0)
				return self
			}
			public var hasAltitudeMMsl:Bool {
				get {
					return builderResult.hasAltitudeMMsl
				}
			}
			public var altitudeMMsl:Float {
				get {
					return builderResult.altitudeMMsl
				}
				set (value) {
					builderResult.hasAltitudeMMsl = true
					builderResult.altitudeMMsl = value
				}
			}
			public func setAltitudeMMsl(value:Float) -> Airmap.Telemetry.Position.Builder {
				self.altitudeMMsl = value
				return self
			}
			public func clearAltitudeMMsl() -> Airmap.Telemetry.Position.Builder{
				builderResult.hasAltitudeMMsl = false
				builderResult.altitudeMMsl = Float(0)
				return self
			}
			override public var internalGetResult:GeneratedMessage {
				get {
					return builderResult
				}
			}
			override public func clear() -> Airmap.Telemetry.Position.Builder {
				builderResult = Airmap.Telemetry.Position()
				return self
			}
			override public func clone() throws -> Airmap.Telemetry.Position.Builder {
				return try Airmap.Telemetry.Position.builderWithPrototype(builderResult)
			}
			override public func build() throws -> Airmap.Telemetry.Position {
				try checkInitialized()
				return buildPartial()
			}
			public func buildPartial() -> Airmap.Telemetry.Position {
				let returnMe:Airmap.Telemetry.Position = builderResult
				return returnMe
			}
			public func mergeFrom(other:Airmap.Telemetry.Position) throws -> Airmap.Telemetry.Position.Builder {
				if other == Airmap.Telemetry.Position() {
					return self
				}
				if other.hasTimestamp {
					timestamp = other.timestamp
				}
				if other.hasLatitude {
					latitude = other.latitude
				}
				if other.hasLongitude {
					longitude = other.longitude
				}
				if other.hasAltitudeMMsl {
					altitudeMMsl = other.altitudeMMsl
				}
				try mergeUnknownFields(other.unknownFields)
				return self
			}
			override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Airmap.Telemetry.Position.Builder {
				return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
			}
			override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Position.Builder {
				let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
				while (true) {
					let protobufTag = try input.readTag()
					switch protobufTag {
					case 0:
						self.unknownFields = try unknownFieldsBuilder.build()
						return self
						
					case 8:
						timestamp = try input.readUInt64()
						
					case 17:
						latitude = try input.readDouble()
						
					case 25:
						longitude = try input.readDouble()
						
					case 37:
						altitudeMMsl = try input.readFloat()
						
					default:
						if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
							unknownFields = try unknownFieldsBuilder.build()
							return self
						}
					}
				}
			}
			class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Airmap.Telemetry.Position.Builder {
				let resultDecodedBuilder = Airmap.Telemetry.Position.Builder()
				if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
					resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
				}
				if let jsonValueLatitude = jsonMap["latitude"] as? NSNumber {
					resultDecodedBuilder.latitude = jsonValueLatitude.doubleValue
				}
				if let jsonValueLongitude = jsonMap["longitude"] as? NSNumber {
					resultDecodedBuilder.longitude = jsonValueLongitude.doubleValue
				}
				if let jsonValueAltitudeMMsl = jsonMap["altitudeMMsl"] as? NSNumber {
					resultDecodedBuilder.altitudeMMsl = jsonValueAltitudeMMsl.floatValue
				}
				return resultDecodedBuilder
			}
			class public func fromJSONToBuilder(data:NSData) throws -> Airmap.Telemetry.Position.Builder {
				let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
				guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
					throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
				}
				return try Airmap.Telemetry.Position.Builder.decodeToBuilder(jsDataCast)
			}
		}
		
	}
	
	final public class Attitude : GeneratedMessage, GeneratedMessageProtocol {
		// Milliseconds since epoc UTC
		public private(set) var hasTimestamp:Bool = false
		public private(set) var timestamp:UInt64 = UInt64(0)
		
		// The aircraft's yaw relative to true North.
		public private(set) var hasYaw:Bool = false
		public private(set) var yaw:Float = Float(0)
		
		// The aircrafts' pitch.
		public private(set) var hasPitch:Bool = false
		public private(set) var pitch:Float = Float(0)
		
		// The aircrafts roll.
		public private(set) var hasRoll:Bool = false
		public private(set) var roll:Float = Float(0)
		
		required public init() {
			super.init()
		}
		override public func isInitialized() -> Bool {
			return true
		}
		override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
			if hasTimestamp {
				try output.writeUInt64(1, value:timestamp)
			}
			if hasYaw {
				try output.writeFloat(2, value:yaw)
			}
			if hasPitch {
				try output.writeFloat(3, value:pitch)
			}
			if hasRoll {
				try output.writeFloat(4, value:roll)
			}
			try unknownFields.writeToCodedOutputStream(output)
		}
		override public func serializedSize() -> Int32 {
			var serialize_size:Int32 = memoizedSerializedSize
			if serialize_size != -1 {
				return serialize_size
			}
			
			serialize_size = 0
			if hasTimestamp {
				serialize_size += timestamp.computeUInt64Size(1)
			}
			if hasYaw {
				serialize_size += yaw.computeFloatSize(2)
			}
			if hasPitch {
				serialize_size += pitch.computeFloatSize(3)
			}
			if hasRoll {
				serialize_size += roll.computeFloatSize(4)
			}
			serialize_size += unknownFields.serializedSize()
			memoizedSerializedSize = serialize_size
			return serialize_size
		}
		public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Airmap.Telemetry.Attitude> {
			var mergedArray = Array<Airmap.Telemetry.Attitude>()
			while let value = try parseFromDelimitedFromInputStream(input) {
				mergedArray += [value]
			}
			return mergedArray
		}
		public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Airmap.Telemetry.Attitude? {
			return try Airmap.Telemetry.Attitude.Builder().mergeDelimitedFromInputStream(input)?.build()
		}
		public class func parseFromData(data:NSData) throws -> Airmap.Telemetry.Attitude {
			return try Airmap.Telemetry.Attitude.Builder().mergeFromData(data, extensionRegistry:Airmap.Telemetry.TelemetryRoot.sharedInstance.extensionRegistry).build()
		}
		public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Attitude {
			return try Airmap.Telemetry.Attitude.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
		}
		public class func parseFromInputStream(input:NSInputStream) throws -> Airmap.Telemetry.Attitude {
			return try Airmap.Telemetry.Attitude.Builder().mergeFromInputStream(input).build()
		}
		public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Attitude {
			return try Airmap.Telemetry.Attitude.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
		}
		public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Airmap.Telemetry.Attitude {
			return try Airmap.Telemetry.Attitude.Builder().mergeFromCodedInputStream(input).build()
		}
		public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Attitude {
			return try Airmap.Telemetry.Attitude.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
		}
		public class func getBuilder() -> Airmap.Telemetry.Attitude.Builder {
			return Airmap.Telemetry.Attitude.classBuilder() as! Airmap.Telemetry.Attitude.Builder
		}
		public func getBuilder() -> Airmap.Telemetry.Attitude.Builder {
			return classBuilder() as! Airmap.Telemetry.Attitude.Builder
		}
		override public class func classBuilder() -> MessageBuilder {
			return Airmap.Telemetry.Attitude.Builder()
		}
		override public func classBuilder() -> MessageBuilder {
			return Airmap.Telemetry.Attitude.Builder()
		}
		public func toBuilder() throws -> Airmap.Telemetry.Attitude.Builder {
			return try Airmap.Telemetry.Attitude.builderWithPrototype(self)
		}
		public class func builderWithPrototype(prototype:Airmap.Telemetry.Attitude) throws -> Airmap.Telemetry.Attitude.Builder {
			return try Airmap.Telemetry.Attitude.Builder().mergeFrom(prototype)
		}
		public func encode() throws -> Dictionary<String,AnyObject> {
			guard isInitialized() else {
				throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
			}
			
			var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
			if hasTimestamp {
				jsonMap["timestamp"] = "\(timestamp)"
			}
			if hasYaw {
				jsonMap["yaw"] = NSNumber(float:yaw)
			}
			if hasPitch {
				jsonMap["pitch"] = NSNumber(float:pitch)
			}
			if hasRoll {
				jsonMap["roll"] = NSNumber(float:roll)
			}
			return jsonMap
		}
		class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Airmap.Telemetry.Attitude {
			return try Airmap.Telemetry.Attitude.Builder.decodeToBuilder(jsonMap).build()
		}
		class public func fromJSON(data:NSData) throws -> Airmap.Telemetry.Attitude {
			return try Airmap.Telemetry.Attitude.Builder.fromJSONToBuilder(data).build()
		}
		public override func getDescription(indent:String) throws -> String {
			var output = ""
			if hasTimestamp {
				output += "\(indent) timestamp: \(timestamp) \n"
			}
			if hasYaw {
				output += "\(indent) yaw: \(yaw) \n"
			}
			if hasPitch {
				output += "\(indent) pitch: \(pitch) \n"
			}
			if hasRoll {
				output += "\(indent) roll: \(roll) \n"
			}
			output += unknownFields.getDescription(indent)
			return output
		}
		override public var hashValue:Int {
			get {
				var hashCode:Int = 7
				if hasTimestamp {
					hashCode = (hashCode &* 31) &+ timestamp.hashValue
				}
				if hasYaw {
					hashCode = (hashCode &* 31) &+ yaw.hashValue
				}
				if hasPitch {
					hashCode = (hashCode &* 31) &+ pitch.hashValue
				}
				if hasRoll {
					hashCode = (hashCode &* 31) &+ roll.hashValue
				}
				hashCode = (hashCode &* 31) &+  unknownFields.hashValue
				return hashCode
			}
		}
		
		
		//Meta information declaration start
		
		override public class func className() -> String {
			return "Airmap.Telemetry.Attitude"
		}
		override public func className() -> String {
			return "Airmap.Telemetry.Attitude"
		}
		override public func classMetaType() -> GeneratedMessage.Type {
			return Airmap.Telemetry.Attitude.self
		}
		//Meta information declaration end
		
		final public class Builder : GeneratedMessageBuilder {
			private var builderResult:Airmap.Telemetry.Attitude = Airmap.Telemetry.Attitude()
			public func getMessage() -> Airmap.Telemetry.Attitude {
				return builderResult
			}
			
			required override public init () {
				super.init()
			}
			public var hasTimestamp:Bool {
				get {
					return builderResult.hasTimestamp
				}
			}
			public var timestamp:UInt64 {
				get {
					return builderResult.timestamp
				}
				set (value) {
					builderResult.hasTimestamp = true
					builderResult.timestamp = value
				}
			}
			public func setTimestamp(value:UInt64) -> Airmap.Telemetry.Attitude.Builder {
				self.timestamp = value
				return self
			}
			public func clearTimestamp() -> Airmap.Telemetry.Attitude.Builder{
				builderResult.hasTimestamp = false
				builderResult.timestamp = UInt64(0)
				return self
			}
			public var hasYaw:Bool {
				get {
					return builderResult.hasYaw
				}
			}
			public var yaw:Float {
				get {
					return builderResult.yaw
				}
				set (value) {
					builderResult.hasYaw = true
					builderResult.yaw = value
				}
			}
			public func setYaw(value:Float) -> Airmap.Telemetry.Attitude.Builder {
				self.yaw = value
				return self
			}
			public func clearYaw() -> Airmap.Telemetry.Attitude.Builder{
				builderResult.hasYaw = false
				builderResult.yaw = Float(0)
				return self
			}
			public var hasPitch:Bool {
				get {
					return builderResult.hasPitch
				}
			}
			public var pitch:Float {
				get {
					return builderResult.pitch
				}
				set (value) {
					builderResult.hasPitch = true
					builderResult.pitch = value
				}
			}
			public func setPitch(value:Float) -> Airmap.Telemetry.Attitude.Builder {
				self.pitch = value
				return self
			}
			public func clearPitch() -> Airmap.Telemetry.Attitude.Builder{
				builderResult.hasPitch = false
				builderResult.pitch = Float(0)
				return self
			}
			public var hasRoll:Bool {
				get {
					return builderResult.hasRoll
				}
			}
			public var roll:Float {
				get {
					return builderResult.roll
				}
				set (value) {
					builderResult.hasRoll = true
					builderResult.roll = value
				}
			}
			public func setRoll(value:Float) -> Airmap.Telemetry.Attitude.Builder {
				self.roll = value
				return self
			}
			public func clearRoll() -> Airmap.Telemetry.Attitude.Builder{
				builderResult.hasRoll = false
				builderResult.roll = Float(0)
				return self
			}
			override public var internalGetResult:GeneratedMessage {
				get {
					return builderResult
				}
			}
			override public func clear() -> Airmap.Telemetry.Attitude.Builder {
				builderResult = Airmap.Telemetry.Attitude()
				return self
			}
			override public func clone() throws -> Airmap.Telemetry.Attitude.Builder {
				return try Airmap.Telemetry.Attitude.builderWithPrototype(builderResult)
			}
			override public func build() throws -> Airmap.Telemetry.Attitude {
				try checkInitialized()
				return buildPartial()
			}
			public func buildPartial() -> Airmap.Telemetry.Attitude {
				let returnMe:Airmap.Telemetry.Attitude = builderResult
				return returnMe
			}
			public func mergeFrom(other:Airmap.Telemetry.Attitude) throws -> Airmap.Telemetry.Attitude.Builder {
				if other == Airmap.Telemetry.Attitude() {
					return self
				}
				if other.hasTimestamp {
					timestamp = other.timestamp
				}
				if other.hasYaw {
					yaw = other.yaw
				}
				if other.hasPitch {
					pitch = other.pitch
				}
				if other.hasRoll {
					roll = other.roll
				}
				try mergeUnknownFields(other.unknownFields)
				return self
			}
			override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Airmap.Telemetry.Attitude.Builder {
				return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
			}
			override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Attitude.Builder {
				let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
				while (true) {
					let protobufTag = try input.readTag()
					switch protobufTag {
					case 0:
						self.unknownFields = try unknownFieldsBuilder.build()
						return self
						
					case 8:
						timestamp = try input.readUInt64()
						
					case 21:
						yaw = try input.readFloat()
						
					case 29:
						pitch = try input.readFloat()
						
					case 37:
						roll = try input.readFloat()
						
					default:
						if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
							unknownFields = try unknownFieldsBuilder.build()
							return self
						}
					}
				}
			}
			class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Airmap.Telemetry.Attitude.Builder {
				let resultDecodedBuilder = Airmap.Telemetry.Attitude.Builder()
				if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
					resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
				}
				if let jsonValueYaw = jsonMap["yaw"] as? NSNumber {
					resultDecodedBuilder.yaw = jsonValueYaw.floatValue
				}
				if let jsonValuePitch = jsonMap["pitch"] as? NSNumber {
					resultDecodedBuilder.pitch = jsonValuePitch.floatValue
				}
				if let jsonValueRoll = jsonMap["roll"] as? NSNumber {
					resultDecodedBuilder.roll = jsonValueRoll.floatValue
				}
				return resultDecodedBuilder
			}
			class public func fromJSONToBuilder(data:NSData) throws -> Airmap.Telemetry.Attitude.Builder {
				let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
				guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
					throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
				}
				return try Airmap.Telemetry.Attitude.Builder.decodeToBuilder(jsDataCast)
			}
		}
		
	}
	
	final public class Speed : GeneratedMessage, GeneratedMessageProtocol {
		// Milliseconds since epoc UTC
		public private(set) var hasTimestamp:Bool = false
		public private(set) var timestamp:UInt64 = UInt64(0)
		
		// Ground speed in meters/second.
		public private(set) var hasGroundSpeedMs:Bool = false
		public private(set) var groundSpeedMs:Float = Float(0)
		
		// Heading relative to True North
		public private(set) var hasTrueHeading:Bool = false
		public private(set) var trueHeading:Float = Float(0)
		
		required public init() {
			super.init()
		}
		override public func isInitialized() -> Bool {
			return true
		}
		override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
			if hasTimestamp {
				try output.writeUInt64(1, value:timestamp)
			}
			if hasGroundSpeedMs {
				try output.writeFloat(2, value:groundSpeedMs)
			}
			if hasTrueHeading {
				try output.writeFloat(3, value:trueHeading)
			}
			try unknownFields.writeToCodedOutputStream(output)
		}
		override public func serializedSize() -> Int32 {
			var serialize_size:Int32 = memoizedSerializedSize
			if serialize_size != -1 {
				return serialize_size
			}
			
			serialize_size = 0
			if hasTimestamp {
				serialize_size += timestamp.computeUInt64Size(1)
			}
			if hasGroundSpeedMs {
				serialize_size += groundSpeedMs.computeFloatSize(2)
			}
			if hasTrueHeading {
				serialize_size += trueHeading.computeFloatSize(3)
			}
			serialize_size += unknownFields.serializedSize()
			memoizedSerializedSize = serialize_size
			return serialize_size
		}
		public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Airmap.Telemetry.Speed> {
			var mergedArray = Array<Airmap.Telemetry.Speed>()
			while let value = try parseFromDelimitedFromInputStream(input) {
				mergedArray += [value]
			}
			return mergedArray
		}
		public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Airmap.Telemetry.Speed? {
			return try Airmap.Telemetry.Speed.Builder().mergeDelimitedFromInputStream(input)?.build()
		}
		public class func parseFromData(data:NSData) throws -> Airmap.Telemetry.Speed {
			return try Airmap.Telemetry.Speed.Builder().mergeFromData(data, extensionRegistry:Airmap.Telemetry.TelemetryRoot.sharedInstance.extensionRegistry).build()
		}
		public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Speed {
			return try Airmap.Telemetry.Speed.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
		}
		public class func parseFromInputStream(input:NSInputStream) throws -> Airmap.Telemetry.Speed {
			return try Airmap.Telemetry.Speed.Builder().mergeFromInputStream(input).build()
		}
		public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Speed {
			return try Airmap.Telemetry.Speed.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
		}
		public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Airmap.Telemetry.Speed {
			return try Airmap.Telemetry.Speed.Builder().mergeFromCodedInputStream(input).build()
		}
		public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Speed {
			return try Airmap.Telemetry.Speed.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
		}
		public class func getBuilder() -> Airmap.Telemetry.Speed.Builder {
			return Airmap.Telemetry.Speed.classBuilder() as! Airmap.Telemetry.Speed.Builder
		}
		public func getBuilder() -> Airmap.Telemetry.Speed.Builder {
			return classBuilder() as! Airmap.Telemetry.Speed.Builder
		}
		override public class func classBuilder() -> MessageBuilder {
			return Airmap.Telemetry.Speed.Builder()
		}
		override public func classBuilder() -> MessageBuilder {
			return Airmap.Telemetry.Speed.Builder()
		}
		public func toBuilder() throws -> Airmap.Telemetry.Speed.Builder {
			return try Airmap.Telemetry.Speed.builderWithPrototype(self)
		}
		public class func builderWithPrototype(prototype:Airmap.Telemetry.Speed) throws -> Airmap.Telemetry.Speed.Builder {
			return try Airmap.Telemetry.Speed.Builder().mergeFrom(prototype)
		}
		public func encode() throws -> Dictionary<String,AnyObject> {
			guard isInitialized() else {
				throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
			}
			
			var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
			if hasTimestamp {
				jsonMap["timestamp"] = "\(timestamp)"
			}
			if hasGroundSpeedMs {
				jsonMap["groundSpeedMs"] = NSNumber(float:groundSpeedMs)
			}
			if hasTrueHeading {
				jsonMap["trueHeading"] = NSNumber(float:trueHeading)
			}
			return jsonMap
		}
		class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Airmap.Telemetry.Speed {
			return try Airmap.Telemetry.Speed.Builder.decodeToBuilder(jsonMap).build()
		}
		class public func fromJSON(data:NSData) throws -> Airmap.Telemetry.Speed {
			return try Airmap.Telemetry.Speed.Builder.fromJSONToBuilder(data).build()
		}
		override public func getDescription(indent:String) throws -> String {
			var output = ""
			if hasTimestamp {
				output += "\(indent) timestamp: \(timestamp) \n"
			}
			if hasGroundSpeedMs {
				output += "\(indent) groundSpeedMs: \(groundSpeedMs) \n"
			}
			if hasTrueHeading {
				output += "\(indent) trueHeading: \(trueHeading) \n"
			}
			output += unknownFields.getDescription(indent)
			return output
		}
		override public var hashValue:Int {
			get {
				var hashCode:Int = 7
				if hasTimestamp {
					hashCode = (hashCode &* 31) &+ timestamp.hashValue
				}
				if hasGroundSpeedMs {
					hashCode = (hashCode &* 31) &+ groundSpeedMs.hashValue
				}
				if hasTrueHeading {
					hashCode = (hashCode &* 31) &+ trueHeading.hashValue
				}
				hashCode = (hashCode &* 31) &+  unknownFields.hashValue
				return hashCode
			}
		}
		
		
		//Meta information declaration start
		
		override public class func className() -> String {
			return "Airmap.Telemetry.Speed"
		}
		override public func className() -> String {
			return "Airmap.Telemetry.Speed"
		}
		override public func classMetaType() -> GeneratedMessage.Type {
			return Airmap.Telemetry.Speed.self
		}
		//Meta information declaration end
		
		final public class Builder : GeneratedMessageBuilder {
			private var builderResult:Airmap.Telemetry.Speed = Airmap.Telemetry.Speed()
			public func getMessage() -> Airmap.Telemetry.Speed {
				return builderResult
			}
			
			required override public init () {
				super.init()
			}
			public var hasTimestamp:Bool {
				get {
					return builderResult.hasTimestamp
				}
			}
			public var timestamp:UInt64 {
				get {
					return builderResult.timestamp
				}
				set (value) {
					builderResult.hasTimestamp = true
					builderResult.timestamp = value
				}
			}
			public func setTimestamp(value:UInt64) -> Airmap.Telemetry.Speed.Builder {
				self.timestamp = value
				return self
			}
			public func clearTimestamp() -> Airmap.Telemetry.Speed.Builder{
				builderResult.hasTimestamp = false
				builderResult.timestamp = UInt64(0)
				return self
			}
			public var hasGroundSpeedMs:Bool {
				get {
					return builderResult.hasGroundSpeedMs
				}
			}
			public var groundSpeedMs:Float {
				get {
					return builderResult.groundSpeedMs
				}
				set (value) {
					builderResult.hasGroundSpeedMs = true
					builderResult.groundSpeedMs = value
				}
			}
			public func setGroundSpeedMs(value:Float) -> Airmap.Telemetry.Speed.Builder {
				self.groundSpeedMs = value
				return self
			}
			public func clearGroundSpeedMs() -> Airmap.Telemetry.Speed.Builder{
				builderResult.hasGroundSpeedMs = false
				builderResult.groundSpeedMs = Float(0)
				return self
			}
			public var hasTrueHeading:Bool {
				get {
					return builderResult.hasTrueHeading
				}
			}
			public var trueHeading:Float {
				get {
					return builderResult.trueHeading
				}
				set (value) {
					builderResult.hasTrueHeading = true
					builderResult.trueHeading = value
				}
			}
			public func setTrueHeading(value:Float) -> Airmap.Telemetry.Speed.Builder {
				self.trueHeading = value
				return self
			}
			public func clearTrueHeading() -> Airmap.Telemetry.Speed.Builder{
				builderResult.hasTrueHeading = false
				builderResult.trueHeading = Float(0)
				return self
			}
			override public var internalGetResult:GeneratedMessage {
				get {
					return builderResult
				}
			}
			override public func clear() -> Airmap.Telemetry.Speed.Builder {
				builderResult = Airmap.Telemetry.Speed()
				return self
			}
			override public func clone() throws -> Airmap.Telemetry.Speed.Builder {
				return try Airmap.Telemetry.Speed.builderWithPrototype(builderResult)
			}
			override public func build() throws -> Airmap.Telemetry.Speed {
				try checkInitialized()
				return buildPartial()
			}
			public func buildPartial() -> Airmap.Telemetry.Speed {
				let returnMe:Airmap.Telemetry.Speed = builderResult
				return returnMe
			}
			public func mergeFrom(other:Airmap.Telemetry.Speed) throws -> Airmap.Telemetry.Speed.Builder {
				if other == Airmap.Telemetry.Speed() {
					return self
				}
				if other.hasTimestamp {
					timestamp = other.timestamp
				}
				if other.hasGroundSpeedMs {
					groundSpeedMs = other.groundSpeedMs
				}
				if other.hasTrueHeading {
					trueHeading = other.trueHeading
				}
				try mergeUnknownFields(other.unknownFields)
				return self
			}
			override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Airmap.Telemetry.Speed.Builder {
				return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
			}
			override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Speed.Builder {
				let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
				while (true) {
					let protobufTag = try input.readTag()
					switch protobufTag {
					case 0:
						self.unknownFields = try unknownFieldsBuilder.build()
						return self
						
					case 8:
						timestamp = try input.readUInt64()
						
					case 21:
						groundSpeedMs = try input.readFloat()
						
					case 29:
						trueHeading = try input.readFloat()
						
					default:
						if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
							unknownFields = try unknownFieldsBuilder.build()
							return self
						}
					}
				}
			}
			class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Airmap.Telemetry.Speed.Builder {
				let resultDecodedBuilder = Airmap.Telemetry.Speed.Builder()
				if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
					resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
				}
				if let jsonValueGroundSpeedMs = jsonMap["groundSpeedMs"] as? NSNumber {
					resultDecodedBuilder.groundSpeedMs = jsonValueGroundSpeedMs.floatValue
				}
				if let jsonValueTrueHeading = jsonMap["trueHeading"] as? NSNumber {
					resultDecodedBuilder.trueHeading = jsonValueTrueHeading.floatValue
				}
				return resultDecodedBuilder
			}
			class public func fromJSONToBuilder(data:NSData) throws -> Airmap.Telemetry.Speed.Builder {
				let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
				guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
					throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
				}
				return try Airmap.Telemetry.Speed.Builder.decodeToBuilder(jsDataCast)
			}
		}
		
	}
	
	final public class Barometer : GeneratedMessage, GeneratedMessageProtocol {
		// Milliseconds since epoc UTC
		public private(set) var hasTimestamp:Bool = false
		public private(set) var timestamp:UInt64 = UInt64(0)
		
		// Barometric reading, hPa
		public private(set) var hasBarometerHpa:Bool = false
		public private(set) var barometerHpa:Float = Float(0)
		
		required public init() {
			super.init()
		}
		override public func isInitialized() -> Bool {
			return true
		}
		override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
			if hasTimestamp {
				try output.writeUInt64(1, value:timestamp)
			}
			if hasBarometerHpa {
				try output.writeFloat(2, value:barometerHpa)
			}
			try unknownFields.writeToCodedOutputStream(output)
		}
		override public func serializedSize() -> Int32 {
			var serialize_size:Int32 = memoizedSerializedSize
			if serialize_size != -1 {
				return serialize_size
			}
			
			serialize_size = 0
			if hasTimestamp {
				serialize_size += timestamp.computeUInt64Size(1)
			}
			if hasBarometerHpa {
				serialize_size += barometerHpa.computeFloatSize(2)
			}
			serialize_size += unknownFields.serializedSize()
			memoizedSerializedSize = serialize_size
			return serialize_size
		}
		public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Airmap.Telemetry.Barometer> {
			var mergedArray = Array<Airmap.Telemetry.Barometer>()
			while let value = try parseFromDelimitedFromInputStream(input) {
				mergedArray += [value]
			}
			return mergedArray
		}
		public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Airmap.Telemetry.Barometer? {
			return try Airmap.Telemetry.Barometer.Builder().mergeDelimitedFromInputStream(input)?.build()
		}
		public class func parseFromData(data:NSData) throws -> Airmap.Telemetry.Barometer {
			return try Airmap.Telemetry.Barometer.Builder().mergeFromData(data, extensionRegistry:Airmap.Telemetry.TelemetryRoot.sharedInstance.extensionRegistry).build()
		}
		public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Barometer {
			return try Airmap.Telemetry.Barometer.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
		}
		public class func parseFromInputStream(input:NSInputStream) throws -> Airmap.Telemetry.Barometer {
			return try Airmap.Telemetry.Barometer.Builder().mergeFromInputStream(input).build()
		}
		public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Barometer {
			return try Airmap.Telemetry.Barometer.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
		}
		public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Airmap.Telemetry.Barometer {
			return try Airmap.Telemetry.Barometer.Builder().mergeFromCodedInputStream(input).build()
		}
		public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Barometer {
			return try Airmap.Telemetry.Barometer.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
		}
		public class func getBuilder() -> Airmap.Telemetry.Barometer.Builder {
			return Airmap.Telemetry.Barometer.classBuilder() as! Airmap.Telemetry.Barometer.Builder
		}
		public func getBuilder() -> Airmap.Telemetry.Barometer.Builder {
			return classBuilder() as! Airmap.Telemetry.Barometer.Builder
		}
		override public class func classBuilder() -> MessageBuilder {
			return Airmap.Telemetry.Barometer.Builder()
		}
		override public func classBuilder() -> MessageBuilder {
			return Airmap.Telemetry.Barometer.Builder()
		}
		public func toBuilder() throws -> Airmap.Telemetry.Barometer.Builder {
			return try Airmap.Telemetry.Barometer.builderWithPrototype(self)
		}
		public class func builderWithPrototype(prototype:Airmap.Telemetry.Barometer) throws -> Airmap.Telemetry.Barometer.Builder {
			return try Airmap.Telemetry.Barometer.Builder().mergeFrom(prototype)
		}
		public func encode() throws -> Dictionary<String,AnyObject> {
			guard isInitialized() else {
				throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
			}
			
			var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
			if hasTimestamp {
				jsonMap["timestamp"] = "\(timestamp)"
			}
			if hasBarometerHpa {
				jsonMap["barometerHpa"] = NSNumber(float:barometerHpa)
			}
			return jsonMap
		}
		class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Airmap.Telemetry.Barometer {
			return try Airmap.Telemetry.Barometer.Builder.decodeToBuilder(jsonMap).build()
		}
		class public func fromJSON(data:NSData) throws -> Airmap.Telemetry.Barometer {
			return try Airmap.Telemetry.Barometer.Builder.fromJSONToBuilder(data).build()
		}
		override public func getDescription(indent:String) throws -> String {
			var output = ""
			if hasTimestamp {
				output += "\(indent) timestamp: \(timestamp) \n"
			}
			if hasBarometerHpa {
				output += "\(indent) barometerHpa: \(barometerHpa) \n"
			}
			output += unknownFields.getDescription(indent)
			return output
		}
		override public var hashValue:Int {
			get {
				var hashCode:Int = 7
				if hasTimestamp {
					hashCode = (hashCode &* 31) &+ timestamp.hashValue
				}
				if hasBarometerHpa {
					hashCode = (hashCode &* 31) &+ barometerHpa.hashValue
				}
				hashCode = (hashCode &* 31) &+  unknownFields.hashValue
				return hashCode
			}
		}
		
		
		//Meta information declaration start
		
		override public class func className() -> String {
			return "Airmap.Telemetry.Barometer"
		}
		override public func className() -> String {
			return "Airmap.Telemetry.Barometer"
		}
		override public func classMetaType() -> GeneratedMessage.Type {
			return Airmap.Telemetry.Barometer.self
		}
		//Meta information declaration end
		
		final public class Builder : GeneratedMessageBuilder {
			private var builderResult:Airmap.Telemetry.Barometer = Airmap.Telemetry.Barometer()
			public func getMessage() -> Airmap.Telemetry.Barometer {
				return builderResult
			}
			
			required override public init () {
				super.init()
			}
			public var hasTimestamp:Bool {
				get {
					return builderResult.hasTimestamp
				}
			}
			public var timestamp:UInt64 {
				get {
					return builderResult.timestamp
				}
				set (value) {
					builderResult.hasTimestamp = true
					builderResult.timestamp = value
				}
			}
			public func setTimestamp(value:UInt64) -> Airmap.Telemetry.Barometer.Builder {
				self.timestamp = value
				return self
			}
			public func clearTimestamp() -> Airmap.Telemetry.Barometer.Builder{
				builderResult.hasTimestamp = false
				builderResult.timestamp = UInt64(0)
				return self
			}
			public var hasBarometerHpa:Bool {
				get {
					return builderResult.hasBarometerHpa
				}
			}
			public var barometerHpa:Float {
				get {
					return builderResult.barometerHpa
				}
				set (value) {
					builderResult.hasBarometerHpa = true
					builderResult.barometerHpa = value
				}
			}
			public func setBarometerHpa(value:Float) -> Airmap.Telemetry.Barometer.Builder {
				self.barometerHpa = value
				return self
			}
			public func clearBarometerHpa() -> Airmap.Telemetry.Barometer.Builder{
				builderResult.hasBarometerHpa = false
				builderResult.barometerHpa = Float(0)
				return self
			}
			override public var internalGetResult:GeneratedMessage {
				get {
					return builderResult
				}
			}
			override public func clear() -> Airmap.Telemetry.Barometer.Builder {
				builderResult = Airmap.Telemetry.Barometer()
				return self
			}
			override public func clone() throws -> Airmap.Telemetry.Barometer.Builder {
				return try Airmap.Telemetry.Barometer.builderWithPrototype(builderResult)
			}
			override public func build() throws -> Airmap.Telemetry.Barometer {
				try checkInitialized()
				return buildPartial()
			}
			public func buildPartial() -> Airmap.Telemetry.Barometer {
				let returnMe:Airmap.Telemetry.Barometer = builderResult
				return returnMe
			}
			public func mergeFrom(other:Airmap.Telemetry.Barometer) throws -> Airmap.Telemetry.Barometer.Builder {
				if other == Airmap.Telemetry.Barometer() {
					return self
				}
				if other.hasTimestamp {
					timestamp = other.timestamp
				}
				if other.hasBarometerHpa {
					barometerHpa = other.barometerHpa
				}
				try mergeUnknownFields(other.unknownFields)
				return self
			}
			override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Airmap.Telemetry.Barometer.Builder {
				return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
			}
			override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Airmap.Telemetry.Barometer.Builder {
				let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
				while (true) {
					let protobufTag = try input.readTag()
					switch protobufTag {
					case 0:
						self.unknownFields = try unknownFieldsBuilder.build()
						return self
						
					case 8:
						timestamp = try input.readUInt64()
						
					case 21:
						barometerHpa = try input.readFloat()
						
					default:
						if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
							unknownFields = try unknownFieldsBuilder.build()
							return self
						}
					}
				}
			}
			class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Airmap.Telemetry.Barometer.Builder {
				let resultDecodedBuilder = Airmap.Telemetry.Barometer.Builder()
				if let jsonValueTimestamp = jsonMap["timestamp"] as? String {
					resultDecodedBuilder.timestamp = UInt64(jsonValueTimestamp)!
				}
				if let jsonValueBarometerHpa = jsonMap["barometerHpa"] as? NSNumber {
					resultDecodedBuilder.barometerHpa = jsonValueBarometerHpa.floatValue
				}
				return resultDecodedBuilder
			}
			class public func fromJSONToBuilder(data:NSData) throws -> Airmap.Telemetry.Barometer.Builder {
				let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
				guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
					throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
				}
				return try Airmap.Telemetry.Barometer.Builder.decodeToBuilder(jsDataCast)
			}
		}
		
	}
	
}

// @@protoc_insertion_point(global_scope)
