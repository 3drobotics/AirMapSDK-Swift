# Customise this file, documentation can be found here:
# https://github.com/fastlane/fastlane/tree/master/fastlane/docs
# All available actions: https://docs.fastlane.tools/actions
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version "2.10.0"

default_platform :ios

platform :ios do
  before_all do
    # ENV["SLACK_URL"] = "https://hooks.slack.com/services/..."    
  end

  desc "Runs all the tests"
  lane :test do
    scan
  end

  desc "Extract Strings from all storyboards, code and upload to PhraseApp"
  lane :uploadstrings do
  
    fastlane_require 'nokogiri'
    fastlane_require 'yaml'
  
    phraseapp_token = YAML.load_file("../.phraseapp-auth.yml")["access_token"]
  
    sh 'xcodebuild -exportLocalizations -project ../Example/Pods/Pods.xcodeproj -exportLanguage en -localizationPath /tmp'
    
    xliff_path = "/tmp/airmap.sdk.en.xliff"
    File.rename("/tmp/en.xliff", xliff_path)  

    doc = File.open(xliff_path) { |f| Nokogiri::XML(f) }
    UI.message "Removing storyboard dynamic string placeholders" 
      
    for unit in doc.css("xliff file body trans-unit")
      
      source = unit.css("source")
  
      # Remove translation units with placeholder or empty strings
      if /\[.*\]/m.match(source.text) || /^\s$/.match(source.text)
        UI.message("Removing placeholder: #{unit["id"]}")
        unit.remove
        next
      end
  
    end
    
    UI.message "Replacing translation unit with localization key name" 
  
    for unit in doc.css("xliff file body trans-unit")
      
      note = unit.at_css "note"
      next unless note
  
      # If note text originated from an iOS storyboard
      if match = /Class = \".*\";.*/.match(note.text)
  
        # Split note objects separated by ; character
        note_objects = note.text.split(";")
  
        # Loop through not objects and remove leading/trailing whitespace
        for object in note_objects.map(&:strip)
  
          # Extract key value pair
          if match = /(.*) = \"(.*)\"/.match(object)
            key, value = match.captures
  
            # If unit contains a comment
            if key == "Note"
              
              if match = /(.*)\|(.*)/.match(value)
                localization_key, comment = match.captures
                objectId = unit["id"]
                # Store the old key in the Note for future round tripping
                note.content = note.text + " AirMapUIObjectId = \"#{objectId}\";"
                # Replace the translation unit id with our localized key name
                unit["id"] = localization_key
                break
              end
  
            end
  
          end
  
        end
  
      end
  
      for source_file in doc.css("xliff file")
        # Remove source files that have no translations
        source_file.remove unless source_file.css("body trans-unit").count > 0
      end
  
      # Find ids that still reference storyboad ids instead of localization keys
      if match = /^...-..-...\..*/.match(unit["id"])
        file = unit.parent.parent["original"].split('/').last
        id = unit["id"]
        source = unit.css("source")
        UI.error("#{file}: Found un-keyed string: \"#{source.text}\" (#{id})")
      end
  
    end
  
    File.write("/tmp/airmap.sdk.en.cleaned.xliff", doc.to_xml)
    sh "cd .. && phraseapp push --access-token #{phraseapp_token}"
    
  end


desc "Download strings from PhraseApp and update the XLIFF with the correct object ids"
lane :downloadstrings do

  fastlane_require 'yaml'
  fastlane_require 'nokogiri'

  # Load config from PhraseApp YAML
  project = YAML.load_file("../.phraseapp.yml")["phraseapp"]["project_id"]
  phraseapp_token = YAML.load_file("../.phraseapp-auth.yml")["access_token"]

  # Get locales for project on PhraseApp
  locales = sh "cd .. && phraseapp locales list #{project} --access-token #{phraseapp_token}"
  locales = JSON.parse(locales)
  locale_codes = locales.map { |loc| loc["code"] }

  # Remove DE translations for now
  locale_codes -= ["de"]

  # Pull translations for project from PhraseApp
  sh "cd .. && phraseapp pull --access-token #{phraseapp_token}"

  UI.message "Replacing key names with object ids"

  files = locale_codes.map { |code| "/tmp/airmap.sdk.#{code}.translated.xliff" }
  
  for file in files
    
    doc = File.open(file) { |f| Nokogiri::XML(f) }

    for source_file in doc.css("xliff file")
      # Remove globals keys not associated with a source file (i.e. those from Android)
      if source_file["original"] == "global"
        for unit in source_file.css("body trans-unit")
          UI.error "Unassociated translation unit #{unit["id"]}"
        end
      source_file.remove if source_file["original"] == "global"
      end
    end      

    for unit in doc.css("xliff file body trans-unit")
      
      note = unit.at_css "note"
      next unless note

      if match = /Class = \".*\";.*/.match(note.text)

        # Split note objects separated by ; character
        note_objects = note.text.split(";")
        # Loop through not objects and remove leading/trailing whitespace
        for object in note_objects.map(&:strip)

          # Extract key value pair
          next unless match = /(.*) = \"(.*)\"/.match(object)
          key, value = match.captures

          # Restore translation unit id
          next unless key == "AirMapUIObjectId"
          unit["id"] = value

          # Delete the old key from the notes
          note_objects.pop()
          note.content = note_objects.join(";") + ";"
          break

        end

      end

    end

    File.write(file, doc.to_xml)

    # Import the localizations into Xcode
    sh "xcodebuild -importLocalizations -project ../Example/Pods/Pods.xcodeproj -localizationPath #{file}"

  end

end

  after_all do |lane|
    # This block is called, only if the executed lane was successful

    # slack(
    #   message: "Successfully deployed new App Update."
    # )
  end

  error do |lane, exception|
    # slack(
    #   message: exception.message,
    #   success: false
    # )
  end
end


# More information about multiple platforms in fastlane: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Platforms.md
# All available actions: https://docs.fastlane.tools/actions

# fastlane reports which actions are used
# No personal data is recorded. Learn more at https://github.com/fastlane/enhancer
